<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Module dlss</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module dlss</h1>
<ul class="index"><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>


<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-lock_type">lock_type()</a></h3>
<p><tt>lock_type() = write | sticky_write | read | none</tt></p>


<h3 class="typedecl"><a name="type-segment_info">segment_info()</a></h3>
<p><tt>segment_info() = #{type =&gt; <a href="#type-storage_type">storage_type()</a>, local =&gt; true | false, nodes =&gt; list()}</tt></p>


<h3 class="typedecl"><a name="type-storage_type">storage_type()</a></h3>
<p><tt>storage_type() = ram | ramdisc | disc</tt></p>


<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#add_node-1">add_node/1</a></td><td>Add a new node to the schema.</td></tr>
<tr><td valign="top"><a href="#add_segment_copy-2">add_segment_copy/2</a></td><td>Add segment_copy to node.</td></tr>
<tr><td valign="top"><a href="#add_storage-2">add_storage/2</a></td><td>	Add storage.</td></tr>
<tr><td valign="top"><a href="#add_storage-3">add_storage/3</a></td><td> Add storage with Options.</td></tr>
<tr><td valign="top"><a href="#delete-2">delete/2</a></td><td>Delete.</td></tr>
<tr><td valign="top"><a href="#delete-3">delete/3</a></td><td>Delete.</td></tr>
<tr><td valign="top"><a href="#dirty_delete-2">dirty_delete/2</a></td><td>Dirty Delete.</td></tr>
<tr><td valign="top"><a href="#dirty_first-1">dirty_first/1</a></td><td>Dirty First.</td></tr>
<tr><td valign="top"><a href="#dirty_last-1">dirty_last/1</a></td><td>Dirty Last.</td></tr>
<tr><td valign="top"><a href="#dirty_next-2">dirty_next/2</a></td><td>Dirty Next.</td></tr>
<tr><td valign="top"><a href="#dirty_prev-2">dirty_prev/2</a></td><td>Dirty Previous.</td></tr>
<tr><td valign="top"><a href="#dirty_read-2">dirty_read/2</a></td><td>Dirty Read.</td></tr>
<tr><td valign="top"><a href="#dirty_write-3">dirty_write/3</a></td><td>Dirty Write.</td></tr>
<tr><td valign="top"><a href="#first-1">first/1</a></td><td>First.</td></tr>
<tr><td valign="top"><a href="#get_nodes-0">get_nodes/0</a></td><td>Get list of all dlss nodes
 Returns
 [node1,node2 ..]
 where the type of a name of a node is an atom.</td></tr>
<tr><td valign="top"><a href="#get_ready_nodes-0">get_ready_nodes/0</a></td><td>Get list of ready dlss nodes
 Returns
 [node1,node2 ..]
 where the type of a name of a node is an atom.</td></tr>
<tr><td valign="top"><a href="#get_segment_info-1">get_segment_info/1</a></td><td> Get segment info.</td></tr>
<tr><td valign="top"><a href="#get_segments-0">get_segments/0</a></td><td>Get list of all dlss segments.</td></tr>
<tr><td valign="top"><a href="#get_segments-1">get_segments/1</a></td><td>Get list of dlss segments for the Storage.</td></tr>
<tr><td valign="top"><a href="#get_storage_type-1">get_storage_type/1</a></td><td>Get storage type.</td></tr>
<tr><td valign="top"><a href="#get_storages-0">get_storages/0</a></td><td>Get list of all dlss storages.</td></tr>
<tr><td valign="top"><a href="#is_local_storage-1">is_local_storage/1</a></td><td>Check if the storage has local only content.</td></tr>
<tr><td valign="top"><a href="#last-1">last/1</a></td><td>Last.</td></tr>
<tr><td valign="top"><a href="#next-2">next/2</a></td><td>Next.</td></tr>
<tr><td valign="top"><a href="#prev-2">prev/2</a></td><td>Previous.</td></tr>
<tr><td valign="top"><a href="#read-2">read/2</a></td><td>Read.</td></tr>
<tr><td valign="top"><a href="#read-3">read/3</a></td><td>Read.</td></tr>
<tr><td valign="top"><a href="#remove_node-1">remove_node/1</a></td><td> Remove a node from the schema.</td></tr>
<tr><td valign="top"><a href="#remove_segment_copy-2">remove_segment_copy/2</a></td><td>Remove segment_copy from node.</td></tr>
<tr><td valign="top"><a href="#remove_storage-1">remove_storage/1</a></td><td>	Remove storage.</td></tr>
<tr><td valign="top"><a href="#stop-0">stop/0</a></td><td>
	Stop the DLSS
 Returns ok, or { error, Reason}.</td></tr>
<tr><td valign="top"><a href="#sync_transaction-1">sync_transaction/1</a></td><td>Wrap the procedure into the ACID transaction.</td></tr>
<tr><td valign="top"><a href="#transaction-1">transaction/1</a></td><td>Wrap the procedure into the ACID transaction.</td></tr>
<tr><td valign="top"><a href="#write-3">write/3</a></td><td>Write.</td></tr>
<tr><td valign="top"><a href="#write-4">write/4</a></td><td>Write.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="add_node-1">add_node/1</a></h3>
<div class="spec">
<p><tt>add_node(Node::node()) -&gt; true | false</tt><br></p>
<p> </p>
</div><p>Add a new node to the schema.
  Returns true when a new node is added or false in other case</p>

<h3 class="function"><a name="add_segment_copy-2">add_segment_copy/2</a></h3>
<div class="spec">
<p><tt>add_segment_copy(Segment::atom(), Node::node()) -&gt; ok | {error, Reason::any()}</tt><br></p>
<p> </p>
</div><p>Add segment_copy to node.
 Function copies the Segment (table) and puts to Node.
 As input function gets Name of segment (atom), and Node
 Returns ok, or { error, Reason}.</p>

<h3 class="function"><a name="add_storage-2">add_storage/2</a></h3>
<div class="spec">
<p><tt>add_storage(Name::atom(), Type::<a href="#type-storage_type">storage_type()</a>) -&gt; ok | no_return()</tt><br></p>
<p> </p>
</div><p>	Add storage.
 It adds a new storage to dlss_schema with creating a new Root Segment (table)
 As input function gets Name of storage as atom and Type as atom.
 Returns ok, or throws Error</p>

<h3 class="function"><a name="add_storage-3">add_storage/3</a></h3>
<div class="spec">
<p><tt>add_storage(Name::atom(), Type::<a href="#type-storage_type">storage_type()</a>, Options::<a href="#type-segment_info">segment_info()</a>) -&gt; ok | no_return()</tt><br></p>
<p> </p>
</div><p> Add storage with Options.
 Function adds a new storage to dlss_schema with creating a new Root Segment (table)
 As input function gets Name of storage as atom,
 Type as atom, and Options as map of
 #{
   type:=Type            :: disc | ram | ramdisc
   nodes:=Nodes,         :: list of atom() [node(),..]
   local:=IsLocal        :: true | false
 }
 Options might be used to change default values of nodes and local.
 Returns: ok, or throws Error</p>

<h3 class="function"><a name="delete-2">delete/2</a></h3>
<div class="spec">
<p><tt>delete(Storage::atom(), Key::any()) -&gt; ok | no_return()</tt><br></p>
<p> </p>
</div><p>Delete.
 Function updates the Value to the '@deleted@' in the Storage with Key,
 which will be ignored on read().
 The function needs to be wrapped in transaction.
 Returns ok or throws Error.</p>

<h3 class="function"><a name="delete-3">delete/3</a></h3>
<div class="spec">
<p><tt>delete(Storage::atom(), Key::any(), Lock::<a href="#type-lock_type">lock_type()</a>) -&gt; ok | no_return()</tt><br></p>
<p> </p>
</div><p>Delete.
 Function updates the Value to the '@deleted@' in the Storage with Key
 and write_lock, which will be ignored on read().
 The function needs to be wrapped in transaction.
 Returns ok or throws Error.</p>

<h3 class="function"><a name="dirty_delete-2">dirty_delete/2</a></h3>
<div class="spec">
<p><tt>dirty_delete(Storage::atom(), Key::any()) -&gt; ok | no_return()</tt><br></p>
<p> </p>
</div><p>Dirty Delete.
 Function updates the Value to the '@deleted@' in the Storage with Key
 which will be ignored on read().
 There is no needs of wrapping in transaction, when using dirty_delete
 Returns ok or throws Error.</p>

<h3 class="function"><a name="dirty_first-1">dirty_first/1</a></h3>
<div class="spec">
<p><tt>dirty_first(Storage::atom()) -&gt; Key::any() | no_return()</tt><br></p>
<p> </p>
</div><p>Dirty First.
 Function gets the first Key of the Storage
 As input function gets Name of storage as atom
 There is no needs of wrapping in transaction, when using dirty_first
 Returns Key, or throws Error</p>

<h3 class="function"><a name="dirty_last-1">dirty_last/1</a></h3>
<div class="spec">
<p><tt>dirty_last(Storage::atom()) -&gt; Key::any() | no_return()</tt><br></p>
<p> </p>
</div><p>Dirty Last.
 Function gets the last Key of the Storage
 As input function gets Name of storage as atom
 There is no needs of wrapping in transaction, when using dirty_last
 Returns Key, or throws Error</p>

<h3 class="function"><a name="dirty_next-2">dirty_next/2</a></h3>
<div class="spec">
<p><tt>dirty_next(Storage::atom(), Key::any()) -&gt; RetKey::any() | '$end_of_table' | no_return()</tt><br></p>
<p> </p>
</div><p>Dirty Next.
 Function gets the next key of the Storage, from given Key
 As input function gets Name of storage as atom and pivot Key
 There is no needs of wrapping in transaction, when using dirty_next
 Returns RetKey, or '$end_of_table' or  throws Error</p>

<h3 class="function"><a name="dirty_prev-2">dirty_prev/2</a></h3>
<div class="spec">
<p><tt>dirty_prev(Storage::atom(), Key::any()) -&gt; RetKey::any() | '$end_of_table' | no_return()</tt><br></p>
<p> </p>
</div><p>Dirty Previous.
 Function gets the previous key of the Storage, from given Key
 As input function gets Name of storage as atom and pivot Key
 There is no needs of wrapping in transaction, when using dirty_previous
 Returns RetKey, or '$end_of_table' or  throws Error</p>

<h3 class="function"><a name="dirty_read-2">dirty_read/2</a></h3>
<div class="spec">
<p><tt>dirty_read(Storage::atom(), Key::any()) -&gt; Value::any() | not_found</tt><br></p>
<p> </p>
</div><p>Dirty Read.
 Function reads the value from Storage with Key.
 There is no needs of wrapping in transaction, when using dirty_read
 Returns Value or not_found.</p>

<h3 class="function"><a name="dirty_write-3">dirty_write/3</a></h3>
<div class="spec">
<p><tt>dirty_write(Storage::atom(), Key::any(), Value::any()) -&gt; ok | no_return()</tt><br></p>
<p> </p>
</div><p>Dirty Write.
 Function writes the Value to the Storage with Key.
 If there is a Key in Storage it just updates,
 else it adds new #kv{key:=Key,value:=Value} to the Storage.
 There is no needs of wrapping in transaction, when using dirty_write
 Returns ok or throws Error.</p>

<h3 class="function"><a name="first-1">first/1</a></h3>
<div class="spec">
<p><tt>first(Storage::atom()) -&gt; Key::any() | no_return()</tt><br></p>
<p> </p>
</div><p>First.
 Function gets the first Key of the Storage
 As input function gets Name of storage as atom
 The function needs to be wrapped in transaction.
 Returns Key, or throws Error</p>

<h3 class="function"><a name="get_nodes-0">get_nodes/0</a></h3>
<div class="spec">
<p><tt>get_nodes() -&gt; ListOfNode::list()</tt><br></p>
<p> </p>
</div><p>Get list of all dlss nodes
 Returns
 [node1,node2 ..]
 where the type of a name of a node is an atom</p>

<h3 class="function"><a name="get_ready_nodes-0">get_ready_nodes/0</a></h3>
<div class="spec">
<p><tt>get_ready_nodes() -&gt; ListOfNode::list()</tt><br></p>
<p> </p>
</div><p>Get list of ready dlss nodes
 Returns
 [node1,node2 ..]
 where the type of a name of a node is an atom</p>

<h3 class="function"><a name="get_segment_info-1">get_segment_info/1</a></h3>
<div class="spec">
<p><tt>get_segment_info(Segment::atom()) -&gt; SegmentInfo::<a href="#type-segment_info">segment_info()</a> | no_return()</tt><br></p>
<p> </p>
</div><p> Get segment info.
 Returns map:
 #{
   type =&gt; Type,      :: disc | ram | ramdisc
   local =&gt; Local,    :: true | false
   nodes =&gt; Nodes     :: list of atom() [node(),..]
   }
 or throws Error</p>

<h3 class="function"><a name="get_segments-0">get_segments/0</a></h3>
<div class="spec">
<p><tt>get_segments() -&gt; AllSegments::list()</tt><br></p>
<p> </p>
</div><p>Get list of all dlss segments.
 Returns:
 [dlss_storage1_1,dlss_storage1_2,dlss_storage2_1 ..],
 where the element of list is the name of segments and has type
 of atom</p>

<h3 class="function"><a name="get_segments-1">get_segments/1</a></h3>
<div class="spec">
<p><tt>get_segments(Storage::atom()) -&gt; StorageSegments::list()</tt><br></p>
<p> </p>
</div><p>Get list of dlss segments for the Storage.
 Returns:
 [dlss_storage1_1,dlss_storage1_2,dlss_storage1_3 ..]
 where the element of list is the name of segments of storage storage1
 and has type of atom</p>

<h3 class="function"><a name="get_storage_type-1">get_storage_type/1</a></h3>
<div class="spec">
<p><tt>get_storage_type(Storage::atom()) -&gt; <a href="#type-storage_type">storage_type()</a> | no_return()</tt><br></p>
<p> </p>
</div><p>Get storage type.
  Returns: ram | ramdisc | disc.
  Each type defines where is the storage was added.</p>

<h3 class="function"><a name="get_storages-0">get_storages/0</a></h3>
<div class="spec">
<p><tt>get_storages() -&gt; ListOfStorage::list()</tt><br></p>
<p> </p>
</div><p>Get list of all dlss storages.
 Returns:
 [storage1,storage2 ..]
 where the type of name of storage is the atom</p>

<h3 class="function"><a name="is_local_storage-1">is_local_storage/1</a></h3>
<div class="spec">
<p><tt>is_local_storage(Storage::atom()) -&gt; boolean() | no_return()</tt><br></p>
<p> </p>
</div><p>Check if the storage has local only content</p>

<h3 class="function"><a name="last-1">last/1</a></h3>
<div class="spec">
<p><tt>last(Storage::atom()) -&gt; Key::any() | no_return()</tt><br></p>
<p> </p>
</div><p>Last.
 Function gets the last Key of the Storage
 As input function gets Name of storage as atom
 The function needs to be wrapped in transaction.
 Returns Key, or throws Error</p>

<h3 class="function"><a name="next-2">next/2</a></h3>
<div class="spec">
<p><tt>next(Storage::atom(), Key::any()) -&gt; RetKey::any() | '$end_of_table' | no_return()</tt><br></p>
<p> </p>
</div><p>Next.
 Function gets the next key of the Storage, from given Key
 As input function gets Name of storage as atom and pivot Key
 The function needs to be wrapped in transaction.
 Returns RetKey, or '$end_of_table' or  throws Error</p>

<h3 class="function"><a name="prev-2">prev/2</a></h3>
<div class="spec">
<p><tt>prev(Storage::atom(), Key::any()) -&gt; RetKey::any() | '$end_of_table' | no_return()</tt><br></p>
<p> </p>
</div><p>Previous.
 Function gets the previous key of the Storage, from given Key
 As input function gets Name of storage as atom and pivot Key
 The function needs to be wrapped in transaction.
 Returns RetKey, or '$end_of_table' or  throws Error</p>

<h3 class="function"><a name="read-2">read/2</a></h3>
<div class="spec">
<p><tt>read(Storage::atom(), Key::any()) -&gt; Value::any() | not_found</tt><br></p>
<p> </p>
</div><p>Read.
  Function reads the value from Storage with Key.
 The function needs to be wrapped in transaction.
 Returns Value or not_found.</p>

<h3 class="function"><a name="read-3">read/3</a></h3>
<div class="spec">
<p><tt>read(Storage::atom(), Key::any(), Lock::<a href="#type-lock_type">lock_type()</a>) -&gt; Value::any() | not_found</tt><br></p>
<p> </p>
</div><p>Read.
  Function reads the value from Storage with Key and lock_type.
 The function needs to be wrapped in transaction.
 Returns Value or not_found.</p>

<h3 class="function"><a name="remove_node-1">remove_node/1</a></h3>
<div class="spec">
<p><tt>remove_node(Node::node()) -&gt; {atomic, ok} | {aborted, Reason::term()}</tt><br></p>
<p> </p>
</div><p> Remove a node from the schema.
 Returns {atomic, ok} when node is removed or {aborted, Reason}
 in negative case</p>

<h3 class="function"><a name="remove_segment_copy-2">remove_segment_copy/2</a></h3>
<div class="spec">
<p><tt>remove_segment_copy(Segment::atom(), Node::node()) -&gt; ok | {error, Reason::any()}</tt><br></p>
<p> </p>
</div><p>Remove segment_copy from node.
 Function removes the Segment (table) from Node.
 As input function gets Name of segment (atom), and Node
 Returns ok, or { error, Reason}.</p>

<h3 class="function"><a name="remove_storage-1">remove_storage/1</a></h3>
<div class="spec">
<p><tt>remove_storage(Name::atom()) -&gt; ok | no_return()</tt><br></p>
<p> </p>
</div><p>	Remove storage.
 Function removes the storage from dlss_schema and deletes all related
 segments (tables)
 As input function gets Name of storage as atom
 Returns ok, or throws Error</p>

<h3 class="function"><a name="stop-0">stop/0</a></h3>
<div class="spec">
<p><tt>stop() -&gt; ok | {error, Reason::any()}</tt><br></p>
<p> </p>
</div><p>
	Stop the DLSS
 Returns ok, or { error, Reason}.</p>

<h3 class="function"><a name="sync_transaction-1">sync_transaction/1</a></h3>
<div class="spec">
<p><tt>sync_transaction(Fun::function()) -&gt; {ok, FunResult::any()} | {error, Reason::any()}</tt><br></p>
<p> </p>
</div><p>Wrap the procedure into the ACID transaction.
  Sync transaction wait all changes are applied</p>

<h3 class="function"><a name="transaction-1">transaction/1</a></h3>
<div class="spec">
<p><tt>transaction(Fun::function()) -&gt; {ok, FunResult::any()} | {error, Reason::any()}</tt><br></p>
<p> </p>
</div><p>Wrap the procedure into the ACID transaction.</p>

<h3 class="function"><a name="write-3">write/3</a></h3>
<div class="spec">
<p><tt>write(Storage::atom(), Key::any(), Value::any()) -&gt; ok | no_return()</tt><br></p>
<p> </p>
</div><p>Write.
 Function writes the Value to the Storage with Key.
 If there is a Key in Storage it just updates,
 else it adds new #kv{key:=Key,value:=Value} to the Storage.
 The function needs to be wrapped in transaction.
 Returns ok or throws Error.</p>

<h3 class="function"><a name="write-4">write/4</a></h3>
<div class="spec">
<p><tt>write(Storage::atom(), Key::any(), Value::any(), Lock::<a href="#type-lock_type">lock_type()</a>) -&gt; ok | no_return()</tt><br></p>
<p> </p>
</div><p>Write.
 Function writes the Value to the Storage with Key and write_locks.
 If there is a Key in Storage it just updates,
 else it adds new #kv{key:=Key,value:=Value} to the Storage.
 The function needs to be wrapped in transaction.
 Returns ok or throws Error.</p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc</i></p>
</body>
</html>
